\section{Basic operational preorders}

Our interest in effect trees is that they provide a 
uniform template for defining 
 \emph{contextual equivalence} for programming languages with algebraic effect operations
specified by signature $\Sigma$. This idea was developed in~\cite{gom}, in the specific case of a polymorphically typed call-by-name functional language with algebraic effects. However, it is not language specific, and we now explain it in a general language-independent way.

We consider how to define a notion of \emph{contextual preorder} between programs in some unspecified programming language with algebraic effects from signature $\Sigma$. (Notions of \emph{contextual equivalence}
are included as a special cases, as any equivalence relation is a preorder.) The general idea of a contextual preorder, is to relate comparable programs $P_1$ and $P_2$ (in a typed language, programs of different type would not be considered comparable), by considering how they behave in any program context $C[-]$ that produces `observable' behaviour. One thing that can certainly be observed is the return value (if any) of a computation, as long as this return value is discrete. In any sufficiently expressive language, such discrete values should be convertible to natural numbers. So it is a not unreasonable  restriction to consider contexts whose return values (if any) are natural numbers.  We call such contexts \emph{ground contexts}.

We thus compare the behaviour of $P_1$ and $P_2$ by wrapping them in ground contexts $C[-]$. Since the programming language contains effects, the `observable'  behaviour of  $C[P_1]$ and $C[P_2]$ will, in general, involve not only return values, but also  the effects performed by the two computations. 
%Moreover, exactly what counts as  `observable' and how it affects the comparison of ground type computations
% will be highly dependent on the specific effects present. 
Independently of the specific effects present, the execution behaviour of any ground type computation $M$ can be captured by an effect tree $|M|$ that represents all the effect operations that $M$ might potentially perform, and their dependencies. This suggests the following uniform approach to defining contextual equivalence.  As long as we have a specified \emph{basic operational preorder}  $\Basicleq$  on ground  computation trees, that is, on the set $\Trees(\Nat)$, we can define 
contextual preorder on comparable programs $P_1,P_2$, by:
\[ P_1 \sqsubseteq_\text{ctxt} P_2 ~ \iff ~
\text{for all ground contexts $C[-]$, $~ |C[P_1]| \Basicleq |C[P_2]|$} \enspace . \]
%
Thus, in general, one may view the definition of  contextual equivalence as being determined by the specification of a 
preorder  $\Basicleq$  on  $\Trees(\Nat)$. Any effect-specific behaviour resulting from  the particular effect operations present is captured in the relation $\Basicleq$ itself. Given this, the remaining definition of the contextual preorder $\sqsubseteq_\text{ctxt}$ is generic, relying only on a general operational semantics that transforms any computation $M$ to its effect tree $|M|$.

In~\cite{gom}, this general approach was developed in detail for 
a polymorphically typed call-by-name functional language with algebraic effects. 
The main result was that the resulting contextual preorder is well-behaved if the basic operational preorder satisfies two properties, called \emph{admissibility} and \emph{compositionality}. Such well-behaved properties include that it the contextual preorder is definable as a {logical relation} (and hence amenable to an important proof technique), and also that, on ground type programs $P_1,P_2$,
the contextual and basic operational preorders coincide (i.e., $P_1 \sqsubseteq_\text{ctxt} P_2$ iff 
$|P_1| \Basicleq |P_2|$).

It is our belief that the conditions of admissibility and compositionality are fundamental ones that  are applicable
across a range of programming  languages. Indeed, we believe that it holds in broad generality that any
admissible, compositional basic operational preorder  give rise  to a well-behaved notion of contextual preorder. In addition to the 
call-by-name language of~\cite{gom}, we have verified this explicitly in the case of a call-by-value functional language with effects,
similar to the language in~\cite{plotkin2001adequacy}. More generally, it seems  that the crucial language-independent property required, for this to hold, is that all effect operations are \emph{algebraic} in the sense of Plotkin and Power ~\cite{plotkin2001adequacy} [[CHECK THIS REFERENCE CONTAINS THE RIGHT USE OF ALGEBRAIC]].

\todo[inline]{PERHAPS PUT MOST OF ABOVE IN INTRO}

In summary, defining a \emph{basic operational preorder} on  $\Trees(\Nat)$ provides a uniform language-independent template for defining contextual preorder. Moreover, if the basic operational is \emph{admissible} and \emph{compositional} then the 
contextual preorder is well behaved. The rest of this section reviews the technical definitions of these notions. 



\begin{definition}[Admissibility]
    A binary relation $R$ on $\Trees(X)$ is \emph{admissible} if,
    for every ascending chain $(t_i)_{i \geq 0}$ and 
    $(t_i')_{i\geq 0}$, we have:
    \[ \text{($\,t_i  R \, t_i'$ for all $i\,$)} ~ \implies~
        \left(\bigsqcup_{i \geq 0} t_i\right) \, R \, \left(\bigsqcup_{i \geq 0} t_i'\right) \enspace .
    \]
\end{definition}

\begin{definition}[Compatibility]
    A binary relation $R$ on $\Trees(X)$ is  \emph{compatible} if,
    for every $o \in \Sigma$ of arity $n$, and for all trees 
     $t_1,\dots, t_n$ and $t'_1, \dots, t'_n$, we have:
    \[ \text{($\,t_i  R \, t'_i$ for all $i = 1, \dots, n\,$)} ~ \implies ~ 
        o(t_1, \dots, t_n) \, R \; o(t'_1, \dots, t'_n) \enspace .
    \]
\end{definition}
If a compatible relation is a preorder then it is called a \emph{precongruence}. If it is an equivalence relation it is called a \emph{congruence}.

\noindent
The next two definitions make use of the substitution operation on trees defined at the end of
Section~\ref{section:trees}.
\begin{definition}[Substitutive]
    A binary relation $R$ on $\Trees(X)$ is  \emph{substitutive} if,
    for all trees $t$, $t'$ and $\{t_x\}_{x \in X}$, we have:
    \[ \text{$\,t\, R \, t'$} ~ \implies ~ 
       t[ x \mapsto t_x] \, R \, t'[ x \mapsto t_x] \enspace .
    \]
\end{definition}



\begin{definition}[Compositionality]
    A binary relation $R$ on $\Trees(X)$ is \emph{compositional} if, for all 
    trees $t$, $t'$,  $\{t_x\}_{x \in X}$,  and $\{t'_x\}_{x \in X}$, we have:
        \[ \text{($\,t \, R \, t'$ and $t_x \, R \, t'_x$ for all $x \in X\,$)} ~ \implies ~ 
        t[ x \mapsto t_x] \, R \, t'[ x \mapsto t'_x] \enspace .
    \]
\end{definition}



\begin{proposition} Let $\Basicleq$ be a preorder  on $\Trees(\mathbb{N})$.
\begin{enumerate} 
\item If  $\Basicleq$ is compositional then it is a substitutive precongruence.
\item If $\Basicleq$ is an admissible substitutive precongruence then it is compositional.
\end{enumerate}
\end{proposition}

\noindent
\todo[inline]{Only give the ideas of the proof to gain space}
\begin{proof}
    \begin{enumerate}
        \item 
            The proof in this case relies on the fact that $\Basicleq$ is reflexive.
            Suppose $\Basicleq$ is compositional, then 
            it is substitutive because if $t \Basicleq t'$, and $\{ t_x \}_{x
            \in X}$ is a family of trees we can use the reflexivity to derive 
            $t_x \Basicleq t_x$, and thus 
            by compositionality $t[ x \mapsto t_x] \Basicleq t'[x \mapsto t_x]$.
            Compatibility relies on the exact same method using reflexivity on 
            the effect operation $t = o((x)_{x \in X})$.

        \item 
            Suppose $\Basicleq$ is admissible, substitutive and compatible. 
            Let $t \Basicleq t'$ and $t_x \Basicleq t_x'$, then substitutivity 
            gives the following relation 
            \begin{equation}
                t[x \mapsto t_x] \Basicleq t'[x \mapsto t_x]
            \end{equation}

            We would like to use compatibility to derive 
            the second equation $t'[x \mapsto t_x] \Basicleq t'[x \mapsto
            t_x']$, however this is only possible if $t'$ is finite. 
            The solution is to use finite approximations $(t_n')$ of $t'$
            satisfying $\sqcup_n t_n' = t'$. For each finite tree $t_n'$
            we have the desired equation, and we can conclude using 
            the admissibility of $\Basicleq$.

            Combining the two inequalities, and using the fact that 
            $\Basicleq$ is transitive we get the desired inequality
            $t[x \mapsto t_x] \Basicleq t'[x \mapsto t_x']$.
    \end{enumerate}
\end{proof}



\todo[inline]{[[MOTIVATE]]}
Following~\cite{gom}, we consider the basic ingredient for specifying  a notion of
contextual equivalence for a programming language to be a preorder $\Basicleq$ on $\Trees(\mathbb{N})$.
As long as the preorder is both admissible and compositional (equivalently an
admissible substitutive precongruence), the mathematical tools of~\cite{gom} and
Sections \textbf{[[WHICH]]} of the present paper are applicable. These allow fundamental properties of contextual equivalence to be proved.

We observe that admissible compositional preorders are closed under arbitrary intersection. That is, if
$\mathcal{R} \subseteq \mathcal{P}(\mathbb{N} \times \mathbb{N})$ is a family of admissible compositional preorders
then so is $\bigcap \mathcal{R}$.

Every family $\mathcal{O} \subseteq \mathcal{P}(\Trees(\mathbb{N}))$ determines a preorder $\Basicleq_\mathcal{O}$ on 
$\Trees(\mathbb{N})$ by
\begin{equation}
\label{equation:observational-preorder}
t \Basicleq_\mathcal{O} t' ~ \Leftrightarrow ~ \forall U \in \mathcal{O}~ (t \in U ~ \Rightarrow ~ t' \in U) \enspace .
\end{equation}

\begin{proposition} 
The following are equivalent for
any admissible  preorder  $\Basicleq$ on $\Trees(\mathbb{N})$.
\begin{enumerate} 
\item $\bot \Basicleq t$,  for every $t \in \Trees(\mathbb{N})$.
\item $t \Treeleq t'$ implies $t \Basicleq t'$ for all $t,t' \in \Trees(\mathbb{N})$.
\end{enumerate}
For an arbitrary preorder $\Basicleq$, the following are equivalent.
\begin{enumerate}
\setcounter{enumi}{2}
\item $\Basicleq$ is admissible and satisfies 1 (equivalently 2) above.
\item $\Basicleq$ arises as $\Basicleq_\mathcal{O}$ for some family $\mathcal{O}$ of Scott-open subsets
of $\Trees(\mathbb{N})$.
\end{enumerate}
\end{proposition}

It is possible to characterise the compositionality property for relations of the form $\Basicleq_\mathcal{O}$, using a notion of \emph{decomposability} of $\mathcal{O}$, see~\cite{gom}. 
\todo[inline]{[[IT WOULD POSSIBLY BE NICE TO REPEAT THIS AND REFINE IT, E.G., TO
REFLECT THE SUBSTITUTIVE PRECONGRUENCE DEFINITION OF COMPOSITIONALITY.]]}



