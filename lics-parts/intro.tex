\section{Introduction}

Contextual equivalence in the style of Morris
has imposed itself as a very simple and powerful
way to express what an equivalence on programs should be. 
Two programs are said to be contextually equivalent if 
they \emph{behave} equivalently under any context. 
However this operational notion of equivalence is rarely usable 
as-is because of the quantification over potentially complex 
contexts, which can lead to unintuitive results \cite{pitts1997operationally}.

For this reason, many other forms of equivalences have 
been developed in the past years: bisimulations 
and their refinements (environmental bisimulations, 
bisimulations up-to) \cite{koutavas2011applicative}, 
game semantics \cite{abramsky1999game}, 
denotational interpretation in domains \cite{scott1982domains}, 
higher order logic on 
programs \cite{honda2005observationally} 
and logical relations \cite{Pitts2000}.

Unsurprisingly one can observe extreme variations on 
the complexity of such methods when changing  
the class of effects studied. This has to do with 
the fact that most of the operational semantics 
are deeply tied with the effects of the language, 
and adding or removing effects changes the overall 
shape of the semantics. For denotational interpretation,
the problem is less visible because it is transposed 
into the difficulty of finding suitable domain theoretic constructions, 
such as powerdomains, distributive laws,
and solutions to domain equations.


The first step to be able to give uniform results 
is to start with a ground language, and parametrize 
the syntax with an \emph{effect signature} $\Sigma$. The ground
language we chose was based on PCF \cite{plotkin1977lcf} 
but adapted to a call-by-value evaluation strategy.
The effect signature is given as a set of term constructors 
with finite arity. This allows for instance to add 
a non-deterministic choice operator. However at this 
stage there is no semantics whatsoever, and syntactically 
the signature of a coin-tossing primitive would be the same one 
for instance.

Then, we build a semantics that reduces a program 
using the signature $\Sigma$ for effects into 
a \emph{computation tree}. The computation tree 
is obtained by interpreting the program until 
an effect is encountered, and then just adding 
this effect as a node to the tree. This is still 
a syntactical transformation, that builds the 
tree of all the effects that should be performed. 
The key to this construction is that it clearly 
separates the semantics of the ground language 
and the semantics of the effects, that is going 
to be determined by \emph{relations on trees}.

Now, the two ingredients to our recipe are 
the signature $\Sigma$ and a relation $\sqeq_b$ 
on trees of type $\Sigma$. Using these two one
can completely capture the contextual equivalence 
by using the well-known framework of logical relations.
Examples of effects that are covered by our 
approach are numerous: non-determinism, probabilities, 
input-output and exceptions. 


We also continue the work done by Plotkin and Power \cite{plotkin2001adequacy}
by using their result to link our setting to the denotational approach. This 
should be considered as an empirical proof of the usefulness of this method. 
Continuing in this direction, we study a concrete example combining
non-determinism and probability, a subject that has been regularly encountered 
in denotational models \cite{tix2009semantic} \cite{JGL-mscs16}
\cite{KeimelP2016} and the study concurrent programs
\cite{Mislove2000} \cite{mislove2004axioms}.


In this section we are going to fix a specific signature $\Sigma$
containing two binary operators \texttt{pr} and \texttt{or}. The two
operators are used to model a language where both probabilistic choice 
and non-determinism coexist. Combining these specific effects has been 
the subject of numerous papers, and even when restricting ourselves to the 
denotational setting, the work of Regina Tix on powercones \cite{tix2009semantic} 
continued afterwards by Plotkin and Keimel \cite{KeimelP2016} on Kegelspitze
shows the interest of such combination.
A more functional version of theses domains can also be found in the work of Jean-Goubault Larrecq 
\cite{JGL-mscs16}.


%% This should be in conclusion ! 
This setting is purposely restricted, and several improvements can 
be added without technical issue. For instance, more complex types 
such as sum, products and even type polymorphism can be studied 
in this context. In fact, logical relations excel in proving parametricity 
results \cite{wadler1989theorems}.
In the spirit of simplicity 
and to allow comparison with the work on bisimulations by
Ugo Dal Lago, Francesco Gavazzo and Paul Blain Levy
\cite{Ugo2017} we take the same kind of effect signature 
as they do. Technically, it means that compared to 
the paper from Johann et al. \cite{gom} it lacks 
three of the four effect constructions, but as noticed 
in the said paper, all of the constructions share the
same pattern of proof, so that they actually treated 
only one of the four cases in their proofs.

