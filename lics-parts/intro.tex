\section{Introduction}

Contextual equivalence in the style of Morris
has imposed itself as a very simple and powerful
way to express what an equivalence on programs should be. 
Two programs are said to be contextually equivalent if 
they \emph{behave} equivalently under any context. 
However this operational notion of equivalence is rarely usable 
as-is because of the quantification over potentially complex 
contexts, which can lead to unintuitive results \cite{pitts1997operationally}.

For this reason, many other forms of equivalences have 
been developed in the past years: bisimulations 
and their refinements (environmental bisimulations, 
bisimulations up-to) \cite{koutavas2011applicative}, 
game semantics \cite{abramsky1999game}, 
denotational interpretation in domains \cite{scott1982domains}, 
higher order logic on 
programs \cite{honda2005observationally} 
and logical relations \cite{Pitts2000}.

Unsurprisingly one can observe extreme variations on 
the complexity of such methods when changing  
the class of effects studied. This has to do with 
the fact that most of the operational semantics 
are deeply tied with the effects of the language, 
and adding or removing effects changes the overall 
shape of the semantics. For denotational interpretation,
the problem is less visible because it is transposed 
into the difficulty of finding suitable domain theoretic constructions, 
such as powerdomains, distributive laws,
and solutions to domain equations.


The first step to be able to give uniform results 
is to start with a ground language, and parametrize 
the syntax with an \emph{effect signature} $\Sigma$. The ground
language we chose was based on PCF \cite{plotkin1977lcf} 
but adapted to a call-by-value evaluation strategy.
The effect signature is given as a set of term constructors 
with finite arity. This allows for instance to add 
a non-deterministic choice operator. However at this 
stage there is no semantics whatsoever, and syntactically 
the signature of a coin-tossing primitive would be the same one 
for instance.

Then, we build a semantics that reduces a program 
using the signature $\Sigma$ for effects into 
a \emph{computation tree}. The computation tree 
is obtained by interpreting the program until 
an effect is encountered, and then just adding 
this effect as a node to the tree. This is still 
a syntactical transformation, that builds the 
tree of all the effects that should be performed. 
The key to this construction is that it clearly 
separates the semantics of the ground language 
and the semantics of the effects, that is going 
to be determined by \emph{relations on trees}.

Now, the two ingredients to our recipe are 
the signature $\Sigma$ and a relation $\sqeq_b$ 
on trees of type $\Sigma$. Using these two one
can completely capture the contextual equivalence 
by using the well-known framework of logical relations.
Examples of effects that are covered by our 
approach are numerous: non-determinism, probabilities, 
input-output and exceptions. 


In the sections 2 and 3 we are going to define what 
a computation tree over a signature $\Sigma$ is, 
and what properties should the relation $\sqeq_b$ 
over trees enjoy to be able to derive our results.

Then, from section 4 to section 6 we propose several 
ways to build such relations using the three classical 
approaches to semantics: by using operational constructions,
denotational interpretations and axiomatic theories.
To illustrate the different methods we 
fix a specific signature $\Sigma$
containing two binary operators \texttt{pr} and \texttt{or}. The two
operators are used to model a language where both probabilistic choice 
and non-determinism coexist, leading to a non-trivial example. 

After having investigated how to build the pairs $(\Sigma, \sqeq_b)$
necessary to our results, we introduce section 7 the actual 
language and its semantics. This is closely followed by 
the definition of contextual equivalence in section 8 where
we derive our first simple results. Then, we characterise 
the contextual equivalence using a logical relation in 
section 9, and then use it to derive some results 
independently from the signature used.
