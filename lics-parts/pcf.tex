\section{Parametrized class of languages}

The studied class of languages is based on PCF \cite{plotkin1977lcf} in a call-by-value setting 
parameterised by additional \emph{effect} operations, which is a setting very similar to 
the one studied by Plotkin and Power in \cite{plotkin2001adequacy}. 
As in  \cite{gom}, where a similar programme was carried out in a call-by-name setting,
our goal is to provide generic mathematical machinery for defining and 
analysing contextual equivalence. 

The parameter for this class of languages is $\Sigma$,  
a set of symbols each of a finite arity.
Fine-grained call-by-value [[REFERENCES]]  is used, instead of regular call-by-value,
because it simplifies the technical development by devolving all sequencing of effects to a single
language construct. 
This is a purely stylistic choice, as there are easy translations between fine-grained and regular call-by-value
[[REFERENCES]].

The type system is fairly simple, with only 
natural numbers and functions from one 
type to another type as it can be seen in Figure \ref{fig:language}.
The type inference rules for this language can be seen in Figure
\ref{fig:inference:typing}, no rule should be surprising
but it is worth mentioning that already the inference 
rules are making a distinction between \emph{computations}
and \emph{values}.

This setting is purposely restricted, and several improvements can 
be added without technical issue. For instance, more complex types 
such as sum, products and even type polymorphism can be studied 
in this context. In fact, logical relations excel in proving parametricity 
results \cite{wadler1989theorems}.
In the spirit of simplicity 
and to allow comparison with the work on bisimulations by
Ugo Dal Lago, Francesco Gavazzo and Paul Blain Levy
\cite{Ugo2017} we take the same kind of effect signature 
as they do. Technically, it means that compared to 
the paper from Johann et al. \cite{gom} it lacks 
three of the four effect constructions, but as noticed 
in the said paper, all of the constructions share the
same pattern of proof, so that they actually treated 
only one of the four cases in their proofs.


\begin{figure}[h!]
    \begin{align*}
        \tau :=& ~\Nat ~|~ \tau \to \tau \\
        V :=& ~x ~|~ \lambda x:\tau. M ~|~ \Zero ~|~ \Succ V \\
        M :=& ~\Ret V ~|~ V V ~|~ \Fix V \\
                    &|~ \lcase{V}{M}{M} \\
                    &|~ \Bind{M}{x:\tau}{M} \\
                    &|~ \sigma(\underbrace{M, \dots, M}_n ) \quad \text{ where } (\sigma,n)  \in \Sigma
    \end{align*}
    \caption{Refined Call-By-Value PCF with effects}
    \label{fig:language}
\end{figure}

\begin{figure}[h!]
    \begin{equation*}
        \begin{array}{rl}
            (\lambda x:\tau. N)M &\leftarrow \Bind{M}{x:\tau}{N} \\
            M N &\rightarrow \Bind{M}{f:\sigma \to \tau}{\Bind{N}{x:\sigma}{ f x }} 
        \end{array}
    \end{equation*}
    \caption{Translation between refined and regular call-by-value}
    \label{fig:refinedNormal}
\end{figure}


\begin{figure}[h]
    \begin{center}
        % Identity on variables 
            \AxiomC{}
            \UnaryInfC{$\Gamma, x:\tau \vdash_V x : \tau$}
            \DisplayProof 
        \hskip 1.5em
        % Return a value 
            \AxiomC{$\Gamma \vdash_V V : \tau$}
            \UnaryInfC{$\Gamma \vdash_C \Ret V : \tau$}
            \DisplayProof 
        \hskip 1.5em
        % Lambda abstraction 
            \AxiomC{$\Gamma, x : \tau \vdash_C M : \tau'$}
            \UnaryInfC{$\Gamma \vdash_V \lambda x:\tau. M : \tau \to \tau'$}
            \DisplayProof 
        \hskip 1.5em
        % Zero 
            \AxiomC{}
            \UnaryInfC{$\Gamma \vdash_V \Zero : \Nat$}
            \DisplayProof
        \hskip 1.5em
        \vskip 1em
        % Succ 
            \AxiomC{$\Gamma \vdash_V V : \Nat$}
            \UnaryInfC{$\Gamma \vdash_V \Succ V : \Nat$}
            \DisplayProof
        \hskip 1.5em
        % Fixed point 
            \AxiomC{$\Gamma \vdash_V V : (\tau \to \tau') \to \tau \to \tau'$}
            \UnaryInfC{$\Gamma \vdash_C \Fix V : \tau \to \tau'$}
            \DisplayProof
        \hskip 1.5em
        % Application  
            \AxiomC{$\Gamma \vdash_V V : \tau \to \tau'$} 
            \AxiomC{$\Gamma \vdash_V W : \tau$}
            \BinaryInfC{$\Gamma \vdash_C V W : \tau'$}
            \DisplayProof
        \hskip 1.5em
        \vskip 1em
        % Case   
            \AxiomC{$\Gamma \vdash_V V : \Nat$} 
            \AxiomC{$\Gamma \vdash_C M_1 : \tau$}
            \AxiomC{$\Gamma, x:\Nat \vdash_C M_2 : \tau$}
            \TrinaryInfC{$\Gamma \vdash_C \lcase{V}{M_1}{M_2} : \tau$}
            \DisplayProof
        \hskip 1.5em
        % Bind 
            \AxiomC{$\Gamma \vdash_C M : \tau$} 
            \AxiomC{$\Gamma, x:\tau \vdash_C N : \tau'$}
            \BinaryInfC{$\Gamma \vdash_C \Bind{M}{x:\tau}{N} : \tau'$}
            \DisplayProof
        \hskip 1.5em
        \vskip 1em
        % Effect 
            \AxiomC{$(\sigma,n) \in \Sigma$}
            \AxiomC{$\forall 1 \leq i \leq n, \quad \Gamma \vdash_C M_i : \tau$}
            \BinaryInfC{$\Gamma \vdash_C \sigma(M_1, \dots, M_n) : \tau$}
            \DisplayProof
    \end{center}
    \caption{Inference rules for typing}
    \label{fig:inference:typing}
\end{figure}


\begin{example}[Signature for combined probabilities and non-determinism]
    In the case of combining non-determinism and probabilities, one can
    consider a fair coin toss $\prEff$ of arity two, with a demonic 
    choice operator $\orEff$ of arity two. The signature of the language 
    is therefore $\Sigma = \{ (\prEff,2), (\orEff,2) \}$.
\end{example}


It can be shown that the set of values of type $\Nat$ is isomorphic to $\mathbb{N}$
and therefore we will identify the two sets using $\underline{n}$ to denote 
the value corresponding to $n$.
